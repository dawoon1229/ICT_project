ICT 멘토링 식사도우미 챗봇 계산식 총 코드를 정리하고 커스터마이징 하였다


<img width="560" alt="Untitled (15)" src="https://github.com/dawoon1229/ICT_project/assets/164113758/d508ff61-bab5-4519-9863-d9f5ff8a3c27">



<img width="575" alt="화면 캡처 2024-06-10 145618" src="https://github.com/dawoon1229/ICT_project/assets/164113758/c5e5edac-0c6c-4d88-9e9e-b1bc31cf724f">



<img width="509" alt="화면 캡처 2024-06-10 145640" src="https://github.com/dawoon1229/ICT_project/assets/164113758/5ebdc384-1b9d-4c0f-9fbf-39f853f91a5f">



<img width="422" alt="화면 캡처 2024-06-10 145719" src="https://github.com/dawoon1229/ICT_project/assets/164113758/b644a1ee-8df0-49d3-830f-c7f6d4c95f33">



총 코드
```python
from fastapi import FastAPI, HTTPException
import httpx
import aiomysql
from aiomysql import DictCursor
import os
from dotenv import load_dotenv
import logging
import backoff
import functools
import urllib.parse
from fastapi.middleware.cors import CORSMiddleware

# 로깅 설정 강화
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

app = FastAPI(
    title="SANARE",
    description="음식에 대해서 질문을 하면 맞춤 정보를 알려줄게요",
    servers=[
        {"url": "https://program-returning-cup-situations.trycloudflare.com"}
    ]
)
# CORS 설정 추가
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 모든 도메인에서의 접근을 허용
    allow_credentials=True,
    allow_methods=["*"],  # 모든 HTTP 메소드를 허용
    allow_headers=["*"],  # 모든 HTTP 헤더를 허용
)
load_dotenv()

# 필수 환경 변수 확인
required_env_vars = ['OPENAI_API_KEY', 'DATABASE_HOST', 'DATABASE_USER', 'DATABASE_PASSWORD', 'DATABASE_DB', 'MFDS_API_KEY']
for var in required_env_vars:
    if not os.getenv(var):
        raise RuntimeError(f"Environment variable {var} is required but not set")

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

# log_exceptions 데코레이터 정의
def log_exceptions(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            logging.error(f"Exception in {func.__name__}: {e}", exc_info=True)
            raise
    return wrapper

# 재시도 횟수를 늘리고 지연 시간 증가
@backoff.on_exception(backoff.expo, httpx.RequestError, max_tries=5, base=2)
async def ask_gpt(prompt):
    logging.info("Starting to call GPT API")
    async with httpx.AsyncClient(timeout=30.0) as client:
        api_url = 'https://api.openai.com/v1/chat/completions'
        headers = {
            'Authorization': f'Bearer {OPENAI_API_KEY}',
            'Content-Type': 'application/json'
        }
        data = {
            "model": "gpt-4",
            "messages": [{"role": "user", "content": prompt, "content_type": "text/plain; charset=utf-8"}]
        }
        try:
            response = await client.post(api_url, json=data, headers=headers)
            response.raise_for_status()
            return response.json()['choices'][0]['message']['content'].strip()
        except httpx.RequestError as e:
            logging.error(f"Network or connection error when calling GPT API: {e}")
            raise HTTPException(status_code=500, detail="Error contacting GPT API: Network or connection error")
        except httpx.HTTPStatusError as e:
            logging.error(f"HTTP error occurred while calling GPT API: {e}")
            raise HTTPException(status_code=e.response.status_code, detail=f"HTTP error: {e}")
        finally:
            logging.info("Finished calling GPT API")

async def create_db_pool():
    logging.info("Creating database pool")
    try:
        pool = await aiomysql.create_pool(
            host=os.getenv('DATABASE_HOST'), port=int(os.getenv('DATABASE_PORT', 4444)),
            user=os.getenv('DATABASE_USER'), password=os.getenv('DATABASE_PASSWORD'),
            db=os.getenv('DATABASE_DB'), charset='utf8', autocommit=True
        )
        logging.info("Database pool created successfully")
        return pool
    except Exception as e:
        logging.error(f"Failed to create database pool: {e}")
        raise

@backoff.on_exception(backoff.expo, httpx.RequestError, max_tries=3)
async def get_food_info(food_item):
    logging.info(f"Fetching average weight and unit for {food_item}")
    prompt = (
        f"{food_item}가 과일이라면 1개당 그램 수, 음식이라면 노인 한 사람이 먹을 수 있는 평균 무게는 몇 그램이며, {food_item}을 세는 단위는 무엇인가요? "
        f"'Weight: [weight] grams, Unit: [unit]' 형식으로 응답해 주세요."
    )
    response = await ask_gpt(prompt)
    logging.info(f"GPT response: {response}")

    try:
        weight_str = response.split('Weight: ')[1].split(' grams')[0].strip()
        unit_str = response.split('Unit: ')[1].split('.')[0].strip()
        explanation = response.split('Explanation: ')[1].strip() if 'Explanation: ' in response else ""

        # 숫자 범위 처리
        if '-' in weight_str or 'About' in weight_str:
            weights = [float(w) for w in weight_str.replace('About', '').replace('Approximately', '').split('-')]
            weight = sum(weights) / len(weights)  # 평균값 계산
        else:
            weight = float(weight_str)

        logging.info(f"Parsed weight: {weight}, unit: {unit_str}, explanation: {explanation}")
        return weight, unit_str, explanation
    except (IndexError, ValueError) as e:
        logging.error(f"Error parsing GPT response: {e}")
        return None, None, "평균 무게나 단위를 알 수 없습니다."

async def get_user_health_data(pool, user_id):
    logging.info(f"Fetching health data for user_id {user_id}")
    async with pool.acquire() as conn:
        async with conn.cursor(DictCursor) as cursor:
            await cursor.execute("SELECT user_id, health, allergy, dietary_restriction FROM health_profiles WHERE user_id = %s;", (user_id,))
            result = await cursor.fetchone()
            if result:
                logging.info(f"Health data found for user_id {user_id}")
                return result
            else:
                logging.warning(f"No health data found for user_id {user_id}")
                raise HTTPException(status_code=404, detail="User not found")

@backoff.on_exception(backoff.expo, httpx.RequestError, max_tries=3)
async def get_food_nutrition_info(food_item):
    logging.info(f"Fetching nutrition info for {food_item}")
    async with httpx.AsyncClient() as client:
        API_KEY = os.getenv('MFDS_API_KEY')
        API_URL = "http://openapi.foodsafetykorea.go.kr/api"
        serviceId = "I2790"  
        dataType = "json"
        startIdx = 1
        endIdx = 1
        
        encoded_food_item = urllib.parse.quote(food_item)
        url = f"{API_URL}/{API_KEY}/{serviceId}/{dataType}/{startIdx}/{endIdx}/DESC_KOR={encoded_food_item}"

        logging.debug(f"Request URL: {url}")  

        try:
            response = await client.get(url)
            response.raise_for_status()
            data = response.json()
            logging.debug(f"Response data: {data}")

            if not data.get('I2790', {}).get('row'):
                logging.error(f"No nutrition data found for {food_item}")
                return None  
            return data['I2790']['row'][0]  
        except httpx.HTTPStatusError as e:
            logging.error(f"HTTP error occurred while fetching nutrition info: {e}")
            raise HTTPException(status_code=e.response.status_code, detail=str(e))
        except httpx.RequestError as e:
            logging.error(f"Request error occurred while fetching nutrition info: {e}")
            raise HTTPException(status_code=500, detail="Error contacting MFDS API")

NUTRIENT_MAPPING = {
    "NUTR_CONT1": "열량",
    "NUTR_CONT2": "탄수화물",
    "NUTR_CONT3": "단백질",
    "NUTR_CONT4": "지방",
    "NUTR_CONT5": "당류",
    "NUTR_CONT6": "나트륨",
    "NUTR_CONT7": "콜레스테롤",
    "NUTR_CONT8": "포화지방산",
    "NUTR_CONT9": "트랜스지방"
}

# 성인병별 영양소 제한 및 가중치
health_conditions_restrictions = {
    "당뇨병": {
        "NUTR_CONT5": (5, 1.5),  # 당류, 가중치 1.5
        "NUTR_CONT2": (20, 1.2)  # 탄수화물, 가중치 1.2
    },
    "고혈압": {
        "NUTR_CONT6": (100, 1.8)  # 나트륨, 가중치 1.8
    },
    "중풍(뇌졸중)": {
        "NUTR_CONT4": (10, 1.6),  # 지방, 가중치 1.6
        "NUTR_CONT7": (200, 1.4)  # 콜레스테롤, 가중치 1.4
    },
    "심근경색(심장병)": {
        "NUTR_CONT8": (3, 1.7),  # 포화지방산, 가중치 1.7
        "NUTR_CONT9": (1, 1.7)   # 트랜스지방, 가중치 1.7
    },
    "동맥경화": {
        "NUTR_CONT8": (3, 1.5),  # 포화지방산, 가중치 1.5
        "NUTR_CONT9": (1, 1.5)   # 트랜스지방, 가중치 1.5
    },
    "골다공증": {
        "NUTR_CONT4": (10, 1.3)  # 지방, 가중치 1.3
    },
    "간경화": {
        "NUTR_CONT4": (10, 1.4),  # 지방, 가중치 1.4
        "NUTR_CONT7": (200, 1.3)  # 콜레스테롤, 가중치 1.3
    },
    "신부전증": {
        "NUTR_CONT3": (30, 1.5),  # 단백질, 가중치 1.5
        "NUTR_CONT6": (100, 1.4)  # 나트륨, 가중치 1.4
    },
    "통풍": {
        "NUTR_CONT3": (20, 1.6),  # 단백질, 가중치 1.6
        "NUTR_CONT4": (10, 1.4)   # 지방, 가중치 1.4
    },
    "심부전증": {
        "NUTR_CONT4": (10, 1.5),  # 지방, 가중치 1.5
        "NUTR_CONT6": (100, 1.5)  # 나트륨, 가중치 1.5
    },
    "뇌경색": {
        "NUTR_CONT4": (10, 1.7),  # 지방, 가중치 1.7
        "NUTR_CONT7": (200, 1.6)  # 콜레스테롤, 가중치 1.6
    },
    "고지혈증": {
        "NUTR_CONT8": (3, 1.8),  # 포화지방산, 가중치 1.8
        "NUTR_CONT9": (1, 1.8)   # 트랜스지방, 가중치 1.8
    },
    "췌장염": {
        "NUTR_CONT4": (10, 1.6),  # 지방, 가중치 1.6
        "NUTR_CONT3": (30, 1.5)   # 단백질, 가중치 1.5
    },
    "담석증": {
        "NUTR_CONT4": (10, 1.5),  # 지방, 가중치 1.5
        "NUTR_CONT7": (200, 1.4)  # 콜레스테롤, 가중치 1.4
    },
    "간염": {
        "NUTR_CONT4": (10, 1.3),  # 지방, 가중치 1.3
        "NUTR_CONT7": (200, 1.2)  # 콜레스테롤, 가중치 1.2
    },
    "비만": {
        "NUTR_CONT4": (10, 1.7),  # 지방, 가중치 1.7
        "NUTR_CONT2": (20, 1.5)   # 탄수화물, 가중치 1.5
    },
    "천식": {
        "NUTR_CONT4": (10, 1.4),  # 지방, 가중치 1.4
        "NUTR_CONT7": (200, 1.3)  # 콜레스테롤, 가중치 1.3
    }
}

def evaluate_health_restrictions(health_conditions, nutrition_info):
    score = 0
    for condition in health_conditions:
        if condition in health_conditions_restrictions:
            restrictions = health_conditions_restrictions[condition]
            for nutrient, (threshold, weight) in restrictions.items():
                if nutrient in nutrition_info:
                    nutrient_value = float(nutrition_info[nutrient])
                    if nutrient_value > threshold:
                        score += (nutrient_value - threshold) * weight
    return score

@app.post("/process_food")
async def process_food(food_item: str, user_id: int):
    try:
        pool = await create_db_pool()
        user_health_data = await get_user_health_data(pool, user_id)
        health_conditions = user_health_data['health'].split(',')

        nutrition_info = await get_food_nutrition_info(food_item)
        if not nutrition_info:
            raise HTTPException(status_code=404, detail="Nutrition information not found for the specified food item")

        health_score = evaluate_health_restrictions(health_conditions, nutrition_info)
        
        return {
            "food_item": food_item,
            "health_score": health_score,
            "nutrition_info": nutrition_info
        }
    except Exception as e:
        logging.error(f"Error processing food item {food_item} for user_id {user_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 서버가 시작될 때 데이터베이스 풀을 생성하도록 설정
@app.on_event("startup")
async def startup():
    app.state.db_pool = await create_db_pool()

# 서버가 종료될 때 데이터베이스 풀을 닫도록 설정
@app.on_event("shutdown")
async def shutdown():
    app.state.db_pool.close()
    await app.state.db_pool.wait_closed()

# DB 풀을 사용하는 엔드포인트
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    try:
        pool = app.state.db_pool
        user_health_data = await get_user_health_data(pool, user_id)
        return user_health_data
    except Exception as e:
        logging.error(f"Error fetching user data for user_id {user_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```
